import {Command, Flags} from '@oclif/core'
import chalk from 'chalk'
import {findUp} from 'find-up'
import {createPromptModule} from 'inquirer'
import ora from 'ora'
import path from 'path'
import fs from 'fs-extra'

export default class Init extends Command {
  static description = `Initialize a new living contracts project`
  static examples = [
    `<%= config.bin %> <%= command.id %>
Initialize a new living contracts project
`,
  ]
  static flags = {
    output: Flags.string({
      char: 'o',
      description: 'Output directory for generated files',
      default: './generated',
    }),
  }

  async run(): Promise<void> {
    const {flags} = await this.parse(Init)

    this.log(chalk.bold.blue('Welcome to the Living Contracts CLI! ðŸš€'))
    this.log()

    const spinner = ora('Detecting project structure...').start()
    const projectInfo = await this.detectProjectStructure()

    // check if project has prisma
    if (!projectInfo.hasPrisma) {
      spinner.fail('No Prisma schema found!')
      this.log(chalk.yellow('Living Contracts requires a Prisma schema.'))
      this.log(chalk.grey('Run `npx prisma init` first, then try again.'))
      this.exit(1)
    }

    spinner.succeed(`Found prisma schema at ${chalk.bold.green(`${projectInfo.prismaSchema}`)}
        `)

    // optional: check if project alredy has a living contracts config, if so, ask if user wants to overwrite
    // for now, just cancel init
    const configPath = path.join(projectInfo.root, 'living-contracts.json')
    if (await fs.pathExists(configPath)) {
      this.log(chalk.yellow('Found existing living contracts config.'))
      this.log(chalk.red('Initialization cancelled.'))
      this.exit(0)
    }

    // gather configuration
    this.log()
    this.log(chalk.bold('Configuration: ðŸ“‹'))

    const prompt = createPromptModule()
    const answers = await prompt([
      {
        type: 'input',
        name: 'output',
        message: 'Output directory for generated files:',
        default: flags.output,
        validate: (input: string) => input.length > 0,
      },
      {
        type: 'checkbox',
        name: 'generators',
        message: 'Select generators to enable:',
        choices: [
          {
            name: 'TypeScript SDK',
            value: 'sdk',
            checked: true,
          },
          {
            name: 'REST API Endpoints',
            value: 'api',
            checked: true,
          },
          {
            name: 'Validation Rules',
            value: 'validation',
            checked: true,
          },
          {
            name: 'Documentation',
            value: 'docs',
            checked: true,
          },
          {
            name: 'Tests',
            value: 'tests',
            checked: false,
          },
        ],
      },
      {
        type: 'confirm',
        name: 'watch',
        message: 'Enable automatic regeneration on schema changes?',
        default: true,
      },
      {
        type: 'confirm',
        name: 'validation',
        message: 'Infer validation rules from existing data?',
        default: true,
      },
    ])

    // create configuration
    const config = {
      version: '1.0.0',
      output: answers.output,
      generators: answers.generators,
      watch: answers.watch,
      inferValidation: answers.validation,
      prismaSchema: projectInfo.prismaSchema,
      include: ['**/*.prisma'],
      exclude: ['node_modules/**', 'dist/**', 'build/**'],
      hooks: {
        beforeGenerate: [],
        afterGenerate: [],
      },
    }

    // write configuration
    const writeSpinner = ora('Writing configuration...').start()

    try {
      // write config file
      await fs.writeJson(configPath, config, {spaces: 2})

      // create output dir
      const outputDir = path.join(projectInfo.root, config.output)
      await fs.ensureDir(outputDir)

      // create .gitignore in output dir
      const gitignorePath = path.join(outputDir, '.gitignore')
      await fs.writeFile(gitignorePath, '# Generated by Living Contracts\n*\n!.gitignore\n')

      // add scripts to package.json
      const packageJsonPath = path.join(projectInfo.root, 'package.json')
      if (await fs.pathExists(packageJsonPath)) {
        const packageJson = await fs.readJson(packageJsonPath)
        packageJson.scripts = packageJson.scripts || {}
        packageJson.scripts['contracts:generate'] = 'living-contracts generate'
        packageJson.scripts['contracts:watch'] = 'living-contracts watch'
        packageJson.scripts['contracts:validate'] = 'living-contracts validate'

        await fs.writeJson(packageJsonPath, packageJson, {spaces: 2})

        writeSpinner.succeed('Configuration written successfully!')
      }
    } catch (error) {
      writeSpinner.fail('Failed to write configuration!')
      this.error(error as Error)
    }

    // initial generation?
    if (answers.generators.length > 0) {
      this.log()

      const {runGenerate} = await prompt([
        {
          type: 'confirm',
          name: 'runGenerate',
          message: 'Run initial generation now?',
          default: true,
        },
      ])

      if (runGenerate) {
        this.log()
        this.log(chalk.gray('Running: living-contracts generate'))

        // call generate command here

        this.log(chalk.green('âœ¨ Initial generation complete!'))
      }
    }

    // final success message
    this.log()
    this.log(chalk.bold.green('âœ… Living Contracts initialized successfully!'))
    this.log()

    this.log('Next steps:')
    this.log(chalk.cyan('  1. Run`npm run contracts:generate` to generate files'))
    if (answers.watch) {
      this.log(chalk.cyan('  2. Run`npm run contracts:watch` for automatic regeneration'))
    }
    if (answers.validation) {
      this.log(chalk.cyan('  3. Run`npm run contracts:validate` to validate your data'))
    }
    this.log(chalk.cyan('  4. Import generated types from ' + chalk.bold(`${answers.output}`)))
    this.log()
    this.log(chalk.bold.blue('Need help? Run "living-contracts --help"'))
  }

  private async detectProjectStructure(): Promise<{
    root: string
    hasPrisma: boolean
    prismaSchema: string | null
  }> {
    const packageJsonPath = await findUp('package.json')

    if (!packageJsonPath) {
      throw new Error('No package.json found. Are you in a Node.js project?')
    }
    const root = path.dirname(packageJsonPath)

    // look for prisma schema
    const schemaLocations = ['prisma/schema.prisma', 'schema.prisma', 'src/prisma/schema.prisma', 'src/schema.prisma']

    let prismaSchema = null
    for (const location of schemaLocations) {
      const fullPath = path.join(root, location)
      if (await fs.pathExists(fullPath)) {
        prismaSchema = fullPath // or location?
        break
      }
    }

    return {
      root,
      hasPrisma: prismaSchema !== null,
      prismaSchema,
    }
  }
}
