import path from 'path';
import type { GeneratorContext as SdkContext, ParsedSchema, Field } from '@living-contracts/types';

export class SdkGenerator {
  constructor(private ctx: SdkContext) {}

  public generate(): string[] {
    const files: string[] = [];
    const { parsedSchema, outputBaseDir } = this.ctx;

    // types.ts
    const typesContent = this.generateTypes(parsedSchema);
    this.ctx.tsProject.createSourceFile(path.join(outputBaseDir, 'types.ts'), typesContent, {
      overwrite: true,
    });
    files.push('sdk/types.ts');

    // client.ts
    const clientContent = this.generateClient(parsedSchema);
    this.ctx.tsProject.createSourceFile(path.join(outputBaseDir, 'client.ts'), clientContent, {
      overwrite: true,
    });
    files.push('sdk/client.ts');

    // index.ts barrel
    const indexContent = `// Generated by Living Contracts\nexport * from './types'\nexport * from './client'\nexport { api } from './client';`;
    this.ctx.tsProject.createSourceFile(path.join(outputBaseDir, 'index.ts'), indexContent, {
      overwrite: true,
    });
    files.push('sdk/index.ts');

    return files;
  }

  private pluralize(str: string): string {
    if (str.endsWith('y')) return str.slice(0, -1) + 'ies';
    if (str.endsWith('s')) return str + 'es';
    return str + 's';
  }

  private getPrismaType(field: Field): string {
    const typeMap: Record<string, string> = {
      String: 'string',
      Int: 'number',
      Float: 'number',
      Boolean: 'boolean',
      DateTime: 'Date',
      Json: 'any',
      Decimal: 'number',
      BigInt: 'bigint',
    };
    return typeMap[field.type] || 'any';
  }

  private generateTypes(schema: ParsedSchema): string {
    const interfaces = schema.models
      .map((model) => {
        const fields = model.fields
          .filter((f) => f.kind !== 'object')
          .map((f) => {
            const optional = f.isRequired ? '' : '?';
            return `${f.name}: ${this.getPrismaType(f)}${optional}`;
          })
          .join('\n');
        return `export interface ${model.name} {\n${fields}\n}`;
      })
      .join('\n\n');

    const enums = schema.enums
      .map((e) => {
        const values = e.values.map((v) => `  ${v.name} = '${v.name}'`).join(',\n');
        return `export enum ${e.name} {\n${values}\n}`;
      })
      .join('\n\n');

    return `// Generated types from Prisma schema\n// Do not edit manually!\n\n${interfaces}\n\n${enums}\n`;
  }

  private generateClient(schema: ParsedSchema): string {
    const modelClients = schema.models
      .map((model) => {
        const modelLower = model.name.toLowerCase();
        const modelPlural = this.pluralize(modelLower);
        return `      ${modelPlural}: {\n        create: async (data: Omit<${model.name}, 'id' | 'createdAt' | 'updatedAt'>): Promise<${model.name}> => {\n          const res = await fetch(\`${'${this.baseURL}'}/${modelPlural}\`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error('Failed to create ${model.name}');\n          return res.json();\n        },\n        findMany: async (params?: { skip?: number; take?: number; where?: Partial<${model.name}> }): Promise<${model.name}[]> => {\n          const q = new URLSearchParams();\n          if (params?.skip) q.set('skip', String(params.skip));\n          if (params?.take) q.set('take', String(params.take));\n          if (params?.where) q.set('where', JSON.stringify(params.where));\n          const res = await fetch(\`${'${this.baseURL}'}/${modelPlural}?${'${q}'}\`);\n          if (!res.ok) throw new Error('Failed to fetch ${modelPlural}');\n          return res.json();\n        },\n        findById: async (id: string | number): Promise<${model.name} | null> => {\n          const res = await fetch(\`${'${this.baseURL}'}/${modelPlural}/\${id}\`);\n          if (res.status === 404) return null;\n          if (!res.ok) throw new Error('Failed to fetch ${model.name}');\n          return res.json();\n        },\n        update: async (id: string | number, data: Partial<Omit<${model.name}, 'id' | 'createdAt' | 'updatedAt'>>): Promise<${model.name}> => {\n          const res = await fetch(\`${'${this.baseURL}'}/${modelPlural}/\${id}\`, {\n            method: 'PATCH',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error('Failed to update ${model.name}');\n          return res.json();\n        },\n        delete: async (id: string | number): Promise<void> => {\n          const res = await fetch(\`${'${this.baseURL}'}/${modelPlural}/\${id}\`, { method: 'DELETE' });\n          if (!res.ok) throw new Error('Failed to delete ${model.name}');\n        },\n      }`;
      })
      .join(',\n\n');

    return `// Generated API client\nimport type { ${schema.models.map((m) => m.name).join(', ')} } from './types';\n\nexport class APIClient {\n  constructor(private baseURL: string) {}\n\n${modelClients}\n}\n\nexport const api = new APIClient(process.env.NEXT_PUBLIC_API_URL || process.env.API_URL || '/api');\n`;
  }
}
